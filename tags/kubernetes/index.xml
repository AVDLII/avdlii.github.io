<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Kubernetes on Agrielio De Lazo II</title>
    <link>https://avdlii.xyz/tags/kubernetes/</link>
    <description>Recent content in Kubernetes on Agrielio De Lazo II</description>
    <image>
      <url>https://avdlii.xyz/img/terminal.png</url>
      <link>https://avdlii.xyz/img/terminal.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 24 Jun 2024 16:24:19 +0800</lastBuildDate><atom:link href="https://avdlii.xyz/tags/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Setting Up Kubernetes Using Kubeadm</title>
      <link>https://avdlii.xyz/posts/kubeadm/</link>
      <pubDate>Mon, 24 Jun 2024 16:24:19 +0800</pubDate>
      
      <guid>https://avdlii.xyz/posts/kubeadm/</guid>
      <description>Creating a working kubernetes cluster from scratch</description>
      <content:encoded><![CDATA[<p>When I am first learning about <strong>Kubernetes</strong>, I am using <code>minikube</code>. But it was all too easy. I want to learn how to set it up from the ground up. What packages are involved, what dependencies, what configuration files should I look for. The answer to this is <code>kubeadm</code>.</p>
<p><code>kubeadm</code> is a command line command that lets me create a *<em>Kubernetes</em> cluster from scratch. But before I can use<code>kubeadm</code>, I have to install some packages and configure some os-level stuff.</p>
<p>I will use <strong>Red Hat Enterprise Linux (RHEL)</strong> to run my <strong>Kubernetes</strong> cluster. These are the steps in  broad strokes:</p>
<ol>
<li>Install all <code>kubernetes</code> package dependencies</li>
<li>Create and activate modprobe modules for <strong>Kubernetes</strong> networking</li>
<li>Configure kernel parameters using <code>sysctl</code> for networking</li>
<li>Download and setup <code>containerd</code></li>
<li>Download and setup <code>runc</code></li>
<li>Download and configure <code>cni</code></li>
<li>Disable swap on OS</li>
<li>Setup the <strong>Kubernetes</strong> repository on the server</li>
<li>Download <strong>Kubernetes</strong> packages</li>
<li>Create a <code>kubernetes control-plane</code> which will act as the main brain of the <strong>Kubernetes</strong> cluster</li>
<li>Create <code>kubernetes workers</code> and join them to the <code>kubernetes control-plane</code> server</li>
</ol>
<p>I know this is far from perfect but its definitely a start.</p>
<p>With this, I can further learn how <strong>Kubernetes</strong> works on a deeper level. One step at a time..</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Thoughts on Kubernetes</title>
      <link>https://avdlii.xyz/posts/thoughts-on-kubernetes/</link>
      <pubDate>Mon, 24 Jun 2024 15:02:03 +0800</pubDate>
      
      <guid>https://avdlii.xyz/posts/thoughts-on-kubernetes/</guid>
      <description>My thoughts on what attracted me in Kubernetes</description>
      <content:encoded><![CDATA[<p>In my previous role, my primary focus was on PostgreSQL databases, specifically in database setup, configuration, and infrastructure rather than on the SQL level. For instance, one of my tasks was establishing streaming replication between a master and two standby database servers.</p>
<p>I found this work incredibly exciting. I vividly remember the satisfaction of getting streaming replication working during my first week on the job. The ability to configure a system from scratch and see it replicate an entire database from one machine to another was exhilarating!</p>
<p>However, as you&rsquo;re likely aware, working with such systems comes with its challenges.</p>
<p>When the master server/node fails, one of the standby servers needs to take over as the new master. This process involves rebuilding the old master, which initially acts as a standby/slave before being promoted again to master. In my experience, this rebuilding process can be slow, particularly for large databases common in large enterprises. In a business environment where time is money, the extended rebuild times can pose significant challenges.</p>
<p>During my time in this role, a former colleague introduced me to an application running on something called <strong>Kubernetes</strong>. He demonstrated a feature where intentionally destroying one of the pods resulted in its automatic replacement without manual intervention or <code>ssh</code>-ing inside the pods to revive it.</p>
<p>Coming from a database background, this experience fascinated me. And that was just the tip of the kubernetes iceberg.</p>
<p>And into the rabbit hole I go..</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
